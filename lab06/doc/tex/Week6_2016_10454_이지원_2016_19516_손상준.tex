\documentclass{article}
\usepackage{bm}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mdwlist}
\usepackage[colorlinks=true]{hyperref}
\usepackage{geometry}
\usepackage{kotex}
\geometry{margin=1in}
\geometry{headheight=2in}
\geometry{top=2in}
\usepackage{palatino}
%\renewcommand{\rmdefault}{palatino}
\usepackage{fancyhdr}

\newcommand{\red}[1]{{\color{red} #1}}
\newcommand{\blue}[1]{{\color{blue} #1}}
\newcommand{\orange}[1]{{\color{orange} #1}}
\newcommand{\purple}[1]{{\color{purple} #1}}

%\pagestyle{fancy}
\rhead{}
\lhead{}
\chead{%
  {\vbox{%
      \vspace{2mm}
      \large
      Hardware System Design 4190.309A\hfill
\\
      Seoul National University
      \\[4mm]
      \textbf{Practice \#6. BRAM to PE controller}\\
      \textbf{Jiwon Lee, Sangjun Son}
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xcolor}
\usepackage{listings}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}

\lstdefinestyle{verilog-style}
{
    language=Verilog,
    basicstyle=\scriptsize\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=10pt,
    tabsize=8,
    moredelim=*[s][\colorIndex]{[}{]},
    literate=*{:}{:}1
}

\makeatletter
\newcommand*\@lbracket{[}
\newcommand*\@rbracket{]}
\newcommand*\@colon{:}
\newcommand*\colorIndex{%
    \edef\@temp{\the\lst@token}%
    \ifx\@temp\@lbracket \color{black}%
    \else\ifx\@temp\@rbracket \color{black}%
    \else\ifx\@temp\@colon \color{black}%
    \else \color{vorange}%
    \fi\fi\fi
}
\makeatother

\usepackage{trace}
%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{paralist}

\usepackage{todonotes}
\setlength{\marginparwidth}{2.15cm}

\usepackage{tikz}
\usetikzlibrary{positioning,shapes,backgrounds}

\begin{document}

\pagestyle{fancy}

\section*{Goal}

\begin{itemize*}
\item Implement PE controller based on PE made in Practice \#5.
\begin{itemize*}
\item PE controller consisted of PE and FSM
\item Inner product made with MAC operation of PE
\end{itemize*}
\item FSM controls PE to calculate inner product with several states. \\
(e.g., \texttt{data1[0]*data2[0] + data1[1]*data2[1] + $\cdots$ + data1[15]*data2[15]})
\end{itemize*}
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{fig/fig1.png}
\caption{PE와 FSM이 결합된 2개의 벡터의 내적을 연산하는 PE Controller module이다.}
\label{fig1}
\end{figure}

\section{Implementation}
\orange{
이번 프로젝트는 Block Random Access Memory와 Processing Element를 각각 구현함으로써 추후 구현할 Matrix-Matrix Multiplication을 수행하기 위한 기본 모듈을 구성하는 것을 목적으로 한다. 아래는 코드 구현과 함께 간략한 아이디어 및 기능에 대한 설명이 (1) BRAM, (2) PE 순으로 진행된다.
}

\subsection{PE Controller}
\orange{
BRAM의 경우 크게 두 부분으로 이뤄져 있다. (1) 모듈이 실행이 되기 전 INIT\_FILE에서 내부 메모리 \texttt{mem}를 읽는 부분과 done 신호가 주어졌을 때, OUT\_FILE에 \texttt{mem}의 상태를 출력하는 부분과, (2) EN, RST, WE 신호가 들어왔을 때 경우에 따라 입력되는 데이터를 \texttt{mem}에 읽고 쓰는 역할을 한다.

\begin{itemize*}
\item 아래에 첨부된 코드 중 21-28 라인의 외부 파일 입출력에 관한 구현 보면, \texttt{initial} 구문을 이용하여 모듈의 생성과 동시에 파일 입출력에 대한 실행 구문에 대한 scope를 지정한다. 
\texttt{\$readmemh} 로 시작함으로써 INIT\_FILE 파일을 읽어 \texttt{mem}에 저장한다. 
그 후 \texttt{done} 신호 들어올 때 까지 대기하다가 신호가 들어오면 \texttt{\$writememh} 함수를 사용해 OUT\_FILE에 \texttt{mem} 데이터를 저장한다.
이 때 함수에 붙어있는 \texttt{\$readmem\textbf{h}}와 \texttt{\$writemem\textbf{h}}의 \textbf{h}는 hexadecimal로 파일에 저장하는 값을 16진수 형태로 저장하는 옵션을 의미한다~\cite{memh}. \\
\item 30-46 라인은 BRAM의 input으로 주어지는 신호에 따라 모듈로써의 기능을 구현하는 부분이다. BRAM\_CLK와 BRAM\_RST 그리고 BRAM\_EN, BRAM\_WE의 신호에 따라 읽기, 쓰기, 초기화, 파일 출력을 위한 기능을 수행하게 된다. BRAM\_RST은 BRAM\_CLK에 Async로, BRAM\_EN, BRAM\_WE는 Sync로 구현하였다.
\begin{itemize*}
\item BRAM\_RST이 posedge일 경우 BRAM\_RDDATA에는 0을 할당한다. (31 라인)
\item BRAM\_EN이 활성화되어 있고 BRAM\_WE 또한 활성화되어 있다면, True를 가지는 bit에 해당하는 영역을 BRAM\_WRDATA에서 \texttt{mem}으로 복사한다. (35-38 라인)
\begin{equation}
\texttt{mem}[ \texttt{addr} ][8*(i+1)-1:8* i ]  \leftarrow \text{BRAM\_WRDATA}[8*(i+1) -1:8* i ] 
\end{equation}
\item BRAM\_EN이 활성화되어 있고 BRAM\_WE이 활성화되어 있다면, 메모리로부터 데이터를 읽어오는 기능을 수행한다. Read에 걸리는 싸이클이 2 cycle이 걸리도록 구현을 해야하기 때문에 \texttt{dout}을 버퍼로 사용해 1 cycle이 추가되도록 한다. (41-42 라인)
\end{itemize*}
\end{itemize*}
}
\subsubsection*{\texttt{MY\_PE\_CONTROLLER}}
\begin{lstlisting}[style={verilog-style}]
`timescale 1ns / 1ps
module my_pe_controller #(
    parameter L_RAM_SIZE = 6,
    parameter BITWIDTH = 32
)(
    input start,
    input reset,
    input clk,
    output [L_RAM_SIZE:0] rdaddr,
    input [BITWIDTH-1:0] rddata,
    output [BITWIDTH-1:0] out,
    output done
);
    parameter DONE_LATENCY = 5;
    parameter S_IDLE = 2'd0, S_LOAD = 2'd1, S_CALC = 2'd2, S_DONE = 2'd3;
    reg [1:0] present_state, next_state;
    
    reg [L_RAM_SIZE:0] cnt_load, cnt_calc;
    reg [2:0] cnt_done;
    reg rst_cnt_load, rst_cnt_calc, rst_cnt_done;
    
    reg [BITWIDTH-1:0] gb1[0:2**L_RAM_SIZE-1];
    reg [BITWIDTH-1:0] gb2[0:2**L_RAM_SIZE-1];
    
    reg [BITWIDTH-1:0] ain;
    reg [BITWIDTH-1:0] bin;
    reg valid = 0;
    
    wire [BITWIDTH-1:0] dout;
    wire dvalid;
    
    always @(posedge clk or posedge reset)
        if (reset) present_state <= S_IDLE; else present_state <= next_state;
        
    always @(posedge clk or posedge rst_cnt_load) 
        if (rst_cnt_load) cnt_load <= 0; else cnt_load <= cnt_load + 1;
    always @(posedge clk or posedge rst_cnt_calc) 
        if (rst_cnt_calc) cnt_calc <= 0;
    always @(posedge clk or posedge rst_cnt_done) 
        if (rst_cnt_done) cnt_done <= 0; else cnt_done <= cnt_done + 1;
    
    always @(*)
        case (present_state)
            S_IDLE: if (start)                              next_state = S_LOAD; else next_state = present_state;
            S_LOAD: if (cnt_load == 2**(L_RAM_SIZE+1)-1)    next_state = S_CALC; else next_state = present_state;
            S_CALC: if (cnt_calc == 2**L_RAM_SIZE)          next_state = S_DONE; else next_state = present_state;
            S_DONE: if (cnt_done == DONE_LATENCY-1)         next_state = S_IDLE; else next_state = present_state;
        endcase
    
    always @(*)
        case (present_state)
            S_LOAD: rst_cnt_load <= 0;
            S_CALC: rst_cnt_calc <= 0;
            S_DONE: rst_cnt_done <= 0;
            default: begin
                rst_cnt_load <= 1; 
                rst_cnt_calc <= 1;
                rst_cnt_done <= 1;
            end
        endcase
        
    always @(rddata or present_state)
        if (present_state == S_LOAD) begin
            if (cnt_load < 2**L_RAM_SIZE) gb1[cnt_load] = rddata; else gb2[cnt_load-2**L_RAM_SIZE] = rddata;
        end
    
    always @(dvalid or present_state)
        if (present_state == S_CALC) begin
            if (dvalid) begin
                cnt_calc <= cnt_calc + 1;
                valid <= 0;
            end
            else begin
                ain <= gb1[cnt_calc];
                bin <= gb2[cnt_calc];
                valid <= 1;
            end
        end
    
    assign rdaddr = present_state == S_LOAD ? cnt_load : 0;
    assign out = present_state == S_DONE ? dout : 0;
    assign done = present_state == S_DONE ? 1 : 0;
    
    my_pe #(L_RAM_SIZE, BITWIDTH) MY_PE(
        .aclk(clk),
        .aresetn(~reset),
        .ain(ain),
        .bin(bin),
        .valid(valid),
        .dvalid(dvalid),
        .dout(dout)
    );
endmodule
\end{lstlisting}

\orange{
MAC모듈의 parameter중 dvalid bit는 연산이 끝난 후, m\_axis\_result\_tdata가 실제 연산의 결과값임을 보장해준다. 따라서, always구문을 사용하여 결과값을 다시 psum register에 저장해 주었다. 코드를 보면, s\_axis\_c\_tdata과 m\_axis\_result\_tdata가 다름을 확인 할 수 있는데, 이는 MAC에서 parallel 하게 cin과 result값을 parameter로 줄 수 없기 때문이다. 따라서, 임시 res register를 이용하여 결과값을 받았고, 이후 그 값을 psum에 할당해주었다.
}

\newpage
\section{Result}

\subsection{Testbench Implementation}
\label{sec:testbench}
아래의 코드는 MY\_PE\_CONTROLLER의 구현의 Validity를 확인하기 위해 검증 시나리오를 설정하고 그에 맞게 구현한 것이다. MY\_CONTROLLER 인스턴스를 입력 벡터의 크기, $2^\texttt{L\_RAM\_SIZE}= 2^4=16$와 저장되는 실수의 자료형 크기, $\texttt{BITWIDTH}=32$를 사용하여 선언하였다.

\orange{
\begin{itemize*}
\item 모든 테스트를 시작하기 전에 \texttt{input.txt}를 초기화하기 위한 과정을 거친다. 주소에 해당하는 인덱스를 값으로 가질 수 있도록 for문을 통해 대입시킨 후 \texttt{\$writememh}를 통해 파일에 저장을 한다 (23-24 라인).\\
\item 테스트벤치에서 BRAM\_EN 신호는 항상 활성화 하고 (45, 55 라인) BRAM\_RST와 \texttt{done} 신호는 모든 데이터 전송이 끝나고 입력과 출력이 완료되었을 때 True를 대입할 것이다 (33-34 라인).\\
\item BRAM\_ADDR의 경우 $i$번째 entry의 주소값은 BRAM에서 2개의 LSB를 사용하지 않으므로 주소값 또한 4의 배수로 증가시켜 대입해 주어야 한다. BRAM\_WE 신호를 주소값이 유지되는 한 구간을 5 CLK 싸이클과 1 CLK 싸이클로 나누어 DISABLE과 ENABLE을 번갈아 대입해준다 (29-31 라인).
\end{itemize*}
}

\subsubsection*{\texttt{TB\_MY\_PE\_CONTROLLER}}
\begin{lstlisting}[style={verilog-style}]
`timescale 1ns / 1ps
module tb_my_pe_controller #(
    parameter L_RAM_SIZE = 4,
    parameter BITWIDTH = 32
)();
    reg [BITWIDTH-1:0] gb[0:2**(L_RAM_SIZE+1)-1];
    reg [BITWIDTH-1:0] rddata;
    wire [BITWIDTH-1:0] out;
    wire [L_RAM_SIZE:0] rdaddr;
    wire done;
    
    reg start, clk, reset;
    integer i;
    
    initial begin
        for(i = 0; i < 2**L_RAM_SIZE; i = i+1) begin
            gb[i]                 = $urandom_range(2**30, 2**30+2**24);
            gb[2**L_RAM_SIZE + i] = $urandom_range(2**30, 2**30+2**24);
        end
    
        clk <= 0;
        start <= 0;
        reset <= 1; #20;
        
        start <= 1;
        reset <= 0; #20;
    end
    
    always #5 clk = ~clk;
    always @(rdaddr) begin
        rddata = gb[rdaddr];
    end
    
    my_pe_controller #(L_RAM_SIZE, BITWIDTH) MY_PE_CONTROLLER(
        .start(start),
        .reset(reset),
        .clk(clk),
        .rdaddr(rdaddr),
        .rddata(rddata),
        .out(out),
        .done(done)
    );
endmodule
\end{lstlisting}

\orange{
위 Testbench 코드를 수행하면 아래의 Figure~\ref{fig2}와 같은 Waveform을 확인할 수 있다. 결과를 자세히 보면 \texttt{mem}에 해당하는 BRAM\_ADDR이 4씩 증가하는 것을 확인할 수 있고 이에 따라 BRAM\_RDDATA1 또한 BRAM\_WE가 비활성화 되어 있을 때 2 cycle을 delay로 읽게 되는 것을 확인할 수 있다. BRAM\_RDDATA1가 곧 BRAM2의 BRAM\_WRDATA2이므로 같은 Waveform을 관찰하였다. \\
}

\subsection{Simulation Results}
Section~\ref{sec:testbench}에서 구현된 테스트 벤치를 실행하면 아래와 같은 Waveform을 확인할 수 있다.

\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform1.png}
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform2.png}
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform3.png}
\caption{Waveform}
\label{fig2}
\end{figure}


\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform4.png}
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform5.png}
\caption{Waveform}
\label{fig3}
\end{figure}

\subsection{Design Implementation}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.49\textwidth]{fig/My_PE_Controller_Design1.png}
	\includegraphics[width=0.49\textwidth]{fig/My_PE_Controller_Design2.png}
\caption{Waveform}
\label{fig3}
\end{figure}

\section{Conclusion}
\orange{
이후 프로젝트에서 어떤 모듈을 구현해야 하는지 Bottom-up으로 구현하다 보니 무슨 기능을 위한 구현인지는 아직 잘 모르겠지만 반대로 이전 lab 세션에서 구현을 진행한 모듈에 대해서는 연계성을 확인할 수 있었다. 지금 구현한 모듈이 앞으로도 쓰일 수 있기 때문에 가독성을 높이면서 최대한 임의 구현 방식을 최대한 피하기 위해 노력하였다. \\

MY\_BRAM 모듈을 구현하면서 WE signal에 따라 \texttt{mem}에 저장하는 statement를 for-generate로 구현해보려 했으나 이런 저런 오류가 나면서 나열형 방식으로 구현해 코드의 효율성이 떨어진다는 나름의 판단을 하였다. 추후 프로젝트를 진행하기 전에 always 구문 안에서 block assignment를 for-generate로 구현하는 방식을 익혀야 겠다는 필요성을 제고하였다~\cite{thomas2008verilog}.\\

MY\_PE 모듈 자체의 구현은 그리 어렵지 않았지만, IP catalog의 floating point MAC모듈의 내부 구조를 모르기 때문에, testbench를 작성하는데 어려움을 겪었는데, 이는 valid bit의 high 설정 후 dvalid bit가 high가 될 때까지의 정확한 clock cycle delay, valid bit와 input parameter가 동시에 할당되었을 때의 비정상적인 출력이 그리 직관적이지는 않았기 때문이라고 생각한다. MY\_PE 모듈도 이후 구현에서 중요한 부분을 차지하기 때문에, 최대한 이번 과제에만 국한되지 않게 구현하려 하였다. 
}

\bibliographystyle{plain}
\bibliography{other}

\end{document}
