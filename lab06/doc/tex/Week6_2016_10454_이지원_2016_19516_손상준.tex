\documentclass{article}
\usepackage{bm}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{mdwlist}
\usepackage[colorlinks=true]{hyperref}
\usepackage{geometry}
\usepackage{kotex}
\geometry{margin=1in}
\geometry{headheight=2in}
\geometry{top=2in}
\usepackage{palatino}
%\renewcommand{\rmdefault}{palatino}
\usepackage{fancyhdr}

\newcommand{\red}[1]{{\color{red} #1}}
\newcommand{\blue}[1]{{\color{blue} #1}}
\newcommand{\orange}[1]{{\color{orange} #1}}
\newcommand{\purple}[1]{{\color{purple} #1}}

%\pagestyle{fancy}
\rhead{}
\lhead{}
\chead{%
  {\vbox{%
      \vspace{2mm}
      \large
      Hardware System Design 4190.309A\hfill
\\
      Seoul National University
      \\[4mm]
      \textbf{Practice \#6. BRAM to PE controller}\\
      \textbf{Jiwon Lee, Sangjun Son}
    }
  }
}

%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xcolor}
\usepackage{listings}
\definecolor{vgreen}{RGB}{104,180,104}
\definecolor{vblue}{RGB}{49,49,255}
\definecolor{vorange}{RGB}{255,143,102}

\lstdefinestyle{verilog-style}
{
    language=Verilog,
    basicstyle=\scriptsize\ttfamily,
    keywordstyle=\color{vblue},
    identifierstyle=\color{black},
    commentstyle=\color{vgreen},
    numbers=left,
    numberstyle=\tiny\color{black},
    numbersep=10pt,
    tabsize=8,
    moredelim=*[s][\colorIndex]{[}{]},
    literate=*{:}{:}1
}

\makeatletter
\newcommand*\@lbracket{[}
\newcommand*\@rbracket{]}
\newcommand*\@colon{:}
\newcommand*\colorIndex{%
    \edef\@temp{\the\lst@token}%
    \ifx\@temp\@lbracket \color{black}%
    \else\ifx\@temp\@rbracket \color{black}%
    \else\ifx\@temp\@colon \color{black}%
    \else \color{vorange}%
    \fi\fi\fi
}
\makeatother

\usepackage{trace}
%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{paralist}

\usepackage{todonotes}
\setlength{\marginparwidth}{2.15cm}

\usepackage{tikz}
\usetikzlibrary{positioning,shapes,backgrounds}

\begin{document}

\pagestyle{fancy}

\section*{Goal}

\begin{itemize*}
\item Implement PE controller based on PE made in Practice \#5.
\begin{itemize*}
\item PE controller consisted of PE and FSM
\item Inner product made with MAC operation of PE
\end{itemize*}
\item FSM controls PE to calculate inner product with several states. \\
(e.g., \texttt{data1[0]*data2[0] + data1[1]*data2[1] + $\cdots$ + data1[15]*data2[15]})
\end{itemize*}
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{fig/fig1.png}
\caption{PE와 FSM이 결합된 2개의 벡터의 내적을 연산하는 PE Controller module이다.}
\label{fig1}
\end{figure}

\section{Implementation}
이번 프로젝트는 지난 프로젝트에서 구현한 Processing Element와 이를 실행을 시키기 위해 사용되었던 테스트벤치 코드를 결합한 새로운 모듈을 구현하는 것을 목적으로 한다. PE Control 모듈은 추후 구현할 Matrix-Matrix Multiplication을 수행하기 위해 존재하는 하위 모듈이다. 아래는 코드 구현과 함께 아이디어 및 기능에 대한 설명이 진행된다.

\subsection{PE Controller}
Figure~\ref{fig1}을 참고하면 Practice \#5에서 구현한 벡터의 내적을 계산할 수 있는 \texttt{my\_pe} 모듈과 그것을 구성하는 Floating-point fused multiplier IP catalog가 존재한다. PE controller에서는 내적을 연산할 벡터의 모음을 Global buffer에 저장한 뒤 PE에 전달, 연산을 수행하게 된다. 상기된 Sequential logic 모듈이 상황에 따라 어떤 기능을 수행할 지 다르게 명시해주어야 하기 때문에 State를 정의하여 FSM의 논리를 모두 구현해준다.\\

PE controller는 IDLE, LOAD, CALC, DONE이라는 총 4가지 state를 가진다. IDLE은 대기 상태를 의미하며 이 때 
\texttt{start} 신호가 입력되면 LOAD state로 전이된다. 이 상태에서는 \texttt{rdaddr} 주소를 Testbench에 전달하여 \texttt{rddata} 값을 하나씩 입력받아 Global buffer에 저장한다.\\

모든 LOAD 과정이 마치면 CALC 단계에서 FP IP catalog를 수행하게 된다. Global buffer에 저장된 16개의 실수 벡터 2개를 추출하여 Multiply-Accumulator를 이용해 내적 값을 구하게 된다. 연산이 모두 끝난 후 state는 DONE으로 넘어가게 되고 5 사이클의 Latency를 가지고 \texttt{done} signal과 함께 결과 값을 반환한다. 5 사이클 이후에는 다시 state를 IDLE 상태로 돌려 놓고 \texttt{start} 신호를 기다린다.\\

\begin{itemize*}
\item 아래에 첨부된 코드 중 3-30 라인은 PE controller의 변수 선언에 관한 내용이다.
\begin{itemize*}
\item \texttt{parameter}에 포함된 (1) \texttt{L\_RAM\_SIZE}는 입력되는 벡터의 크기를 표현하는 상수이고 (2) \texttt{BITWIDTH}는 연산을 하기 위한 실수 자료형의 크기를 나타낸다. 나머지 입력과 출력에 관한 Wire는 모두 Figure~\ref{fig1}에서 표기한 바와 같다. 
\item FSM과 관련된 변수는 현재 상태와 앞으로 업데이트해야하는 상태 변수 \texttt{present\_state}와 \texttt{next\_state}가 있고 그 외에 Counter가 있다. 상태를 나타내는 상수는 총 네 가지로 $0 \sim 3$의 값을 \texttt{S\_IDLE}, \texttt{S\_LOAD}, \texttt{S\_CALC}과 \texttt{S\_DONE}에 해당하도록 설정하였다.
\item 내장 모듈인 MY\_PE의 입출력 변수 \texttt{ain}, \texttt{bin}, \texttt{valid}, \texttt{dout}, \texttt{dvalid}를 함께 선언하고 지정시켜주어야 한다.
\end{itemize*}

\item 32-23 라인과 42-78 라인은 강의시간에 배운 FSM의 format을 그대로 차용하여 구현하였다. 초기 상태를 \texttt{reset} 신호와 함께 IDLE 상태로 초기화 한다. 현재 상태에서 어떤 조건이 중족되었을 때 다음 상태를 지정해주는 논리를 구현해준다.
\begin{itemize*}
\item IDLE 상태에서 \texttt{start} 신호가 들어올 경우 LOAD로 전환. (44 라인)
\item LOAD 상태에서 테스트 벤치에서 모든 데이터 (\texttt{cnt\_load} 갯수 만큼의 데이터)를 전달받아 연산에 쓰일 값들이 Global buffer에 전부 저장이 되었을 경우 CALC로 전환. (45 라인)
\item CALC 상태에서 내장 모듈 MY\_PE에서 2개의 벡터의 크기만큼의 연산을 모두 마쳤을 경우 (\texttt{cnt\_calc} 갯수 만큼의 Fused multiplication 수행) DONE로 전환. (46 라인)
\item DONE 상태에서 Latency 만큼 딜레이가 진행된 후에 (Clock이 \texttt{cnt\_done} 만큼 경과된 후) IDLE로 전환. (47 라인)
\end{itemize*}

\item 50-60라인은 각 상태에 위치했을 때 어떤 Counter를 활성화 시킬지 지정해주는 부분이다. 62-65라인에서는 현재 상태가 LOAD에 이르렀을 때 테스트벤치로 \texttt{rdaddr}을 전달해주고 해당하는 실수형 자료 \texttt{rddata}를 받아와 Global buffer에 저장한다.
\end{itemize*}


\subsubsection*{\texttt{MY\_PE\_CONTROLLER}}
\begin{lstlisting}[style={verilog-style}]
`timescale 1ns / 1ps
module my_pe_controller #(
    parameter L_RAM_SIZE = 6,
    parameter BITWIDTH = 32
)(
    input start,
    input reset,
    input clk,
    output [L_RAM_SIZE:0] rdaddr,
    input [BITWIDTH-1:0] rddata,
    output [BITWIDTH-1:0] out,
    output done
);
    parameter DONE_LATENCY = 5;
    parameter S_IDLE = 2'd0, S_LOAD = 2'd1, S_CALC = 2'd2, S_DONE = 2'd3;
    reg [1:0] present_state, next_state;
    
    reg [L_RAM_SIZE:0] cnt_load, cnt_calc;
    reg [2:0] cnt_done;
    reg rst_cnt_load, rst_cnt_calc, rst_cnt_done;
    
    reg [BITWIDTH-1:0] gb1[0:2**L_RAM_SIZE-1];
    reg [BITWIDTH-1:0] gb2[0:2**L_RAM_SIZE-1];
    
    reg [BITWIDTH-1:0] ain;
    reg [BITWIDTH-1:0] bin;
    reg valid = 0;
    
    wire [BITWIDTH-1:0] dout;
    wire dvalid;
    
    always @(posedge clk or posedge reset)
        if (reset) present_state <= S_IDLE; else present_state <= next_state;
        
    always @(posedge clk or posedge rst_cnt_load) 
        if (rst_cnt_load) cnt_load <= 0; else cnt_load <= cnt_load + 1;
    always @(posedge clk or posedge rst_cnt_calc) 
        if (rst_cnt_calc) cnt_calc <= 0;
    always @(posedge clk or posedge rst_cnt_done) 
        if (rst_cnt_done) cnt_done <= 0; else cnt_done <= cnt_done + 1;
    
    always @(*)
        case (present_state)
            S_IDLE: if (start)                              next_state = S_LOAD; else next_state = present_state;
            S_LOAD: if (cnt_load == 2**(L_RAM_SIZE+1)-1)    next_state = S_CALC; else next_state = present_state;
            S_CALC: if (cnt_calc == 2**L_RAM_SIZE)          next_state = S_DONE; else next_state = present_state;
            S_DONE: if (cnt_done == DONE_LATENCY-1)         next_state = S_IDLE; else next_state = present_state;
        endcase
    
    always @(*)
        case (present_state)
            S_LOAD: rst_cnt_load <= 0;
            S_CALC: rst_cnt_calc <= 0;
            S_DONE: rst_cnt_done <= 0;
            default: begin
                rst_cnt_load <= 1; 
                rst_cnt_calc <= 1;
                rst_cnt_done <= 1;
            end
        endcase
        
    always @(rddata or present_state)
        if (present_state == S_LOAD) begin
            if (cnt_load < 2**L_RAM_SIZE) gb1[cnt_load] = rddata; else gb2[cnt_load-2**L_RAM_SIZE] = rddata;
        end
    
    always @(dvalid or present_state)
        if (present_state == S_CALC) begin
            if (dvalid) begin
                cnt_calc <= cnt_calc + 1;
                valid <= 0;
            end
            else begin
                ain <= gb1[cnt_calc];
                bin <= gb2[cnt_calc];
                valid <= 1;
            end
        end
    
    assign rdaddr = present_state == S_LOAD ? cnt_load : 0;
    assign out = present_state == S_DONE ? dout : 0;
    assign done = present_state == S_DONE ? 1 : 0;
    
    my_pe #(L_RAM_SIZE, BITWIDTH) MY_PE(
        .aclk(clk),
        .aresetn(~reset),
        .ain(ain),
        .bin(bin),
        .valid(valid),
        .dvalid(dvalid),
        .dout(dout)
    );
endmodule
\end{lstlisting}

코드의 하단부에는 지난 실습에서 구현한 Floating point MAC모듈의 호출 부분이다. Parameter에 들어가는 값은 모두 변수명과 동일하게 매칭을 해주었다~\cite{thomas2008verilog}.

\newpage
\section{Result}

\subsection{Testbench Implementation}
\label{sec:testbench}
아래의 코드는 MY\_PE\_CONTROLLER의 구현의 Validity를 확인하기 위해 검증 시나리오를 설정하고 그에 맞게 구현한 것이다. MY\_CONTROLLER 인스턴스를 입력 벡터의 크기, $2^\texttt{L\_RAM\_SIZE}= 2^4=16$와 저장되는 실수의 자료형 크기, $\texttt{BITWIDTH}=32$를 사용하여 선언하였다.

\orange{
\begin{itemize*}
\item 모든 테스트를 시작하기 전에 \texttt{input.txt}를 초기화하기 위한 과정을 거친다. 주소에 해당하는 인덱스를 값으로 가질 수 있도록 for문을 통해 대입시킨 후 \texttt{\$writememh}를 통해 파일에 저장을 한다 (23-24 라인).\\
\item 테스트벤치에서 BRAM\_EN 신호는 항상 활성화 하고 (45, 55 라인) BRAM\_RST와 \texttt{done} 신호는 모든 데이터 전송이 끝나고 입력과 출력이 완료되었을 때 True를 대입할 것이다 (33-34 라인).\\
\item BRAM\_ADDR의 경우 $i$번째 entry의 주소값은 BRAM에서 2개의 LSB를 사용하지 않으므로 주소값 또한 4의 배수로 증가시켜 대입해 주어야 한다. BRAM\_WE 신호를 주소값이 유지되는 한 구간을 5 CLK 싸이클과 1 CLK 싸이클로 나누어 DISABLE과 ENABLE을 번갈아 대입해준다 (29-31 라인).
\end{itemize*}
}

\subsubsection*{\texttt{TB\_MY\_PE\_CONTROLLER}}
\begin{lstlisting}[style={verilog-style}]
`timescale 1ns / 1ps
module tb_my_pe_controller #(
    parameter L_RAM_SIZE = 4,
    parameter BITWIDTH = 32
)();
    reg [BITWIDTH-1:0] gb[0:2**(L_RAM_SIZE+1)-1];
    reg [BITWIDTH-1:0] rddata;
    wire [BITWIDTH-1:0] out;
    wire [L_RAM_SIZE:0] rdaddr;
    wire done;
    
    reg start, clk, reset;
    integer i;
    
    initial begin
        for(i = 0; i < 2**L_RAM_SIZE; i = i+1) begin
            gb[i]                 = $urandom_range(2**30, 2**30+2**24);
            gb[2**L_RAM_SIZE + i] = $urandom_range(2**30, 2**30+2**24);
        end
    
        clk <= 0;
        start <= 0;
        reset <= 1; #20;
        
        start <= 1;
        reset <= 0; #20;
    end
    
    always #5 clk = ~clk;
    always @(rdaddr) begin
        rddata = gb[rdaddr];
    end
    
    my_pe_controller #(L_RAM_SIZE, BITWIDTH) MY_PE_CONTROLLER(
        .start(start),
        .reset(reset),
        .clk(clk),
        .rdaddr(rdaddr),
        .rddata(rddata),
        .out(out),
        .done(done)
    );
endmodule
\end{lstlisting}

\orange{
위 Testbench 코드를 수행하면 아래의 Figure~\ref{fig2}와 같은 Waveform을 확인할 수 있다. 결과를 자세히 보면 \texttt{mem}에 해당하는 BRAM\_ADDR이 4씩 증가하는 것을 확인할 수 있고 이에 따라 BRAM\_RDDATA1 또한 BRAM\_WE가 비활성화 되어 있을 때 2 cycle을 delay로 읽게 되는 것을 확인할 수 있다. BRAM\_RDDATA1가 곧 BRAM2의 BRAM\_WRDATA2이므로 같은 Waveform을 관찰하였다. \\
}

\subsection{Simulation Results}
Section~\ref{sec:testbench}에서 구현된 테스트 벤치를 실행하면 아래와 같은 Waveform을 확인할 수 있다.

\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform1.png}
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform2.png}
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform3.png}
\caption{Waveform}
\label{fig2}
\end{figure}


\begin{figure}[ht]
	\centering
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform4.png}
	\includegraphics[width=1.0\textwidth]{fig/My_PE_Controller_Waveform5.png}
\caption{Waveform}
\label{fig3}
\end{figure}

\subsection{Design Implementation}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.49\textwidth]{fig/My_PE_Controller_Design1.png}
	\includegraphics[width=0.49\textwidth]{fig/My_PE_Controller_Design2.png}
\caption{Implementation design}
\label{fig3}
\end{figure}

\section{Conclusion}
\orange{
이후 프로젝트에서 어떤 모듈을 구현해야 하는지 Bottom-up으로 구현하다 보니 무슨 기능을 위한 구현인지는 아직 잘 모르겠지만 반대로 이전 lab 세션에서 구현을 진행한 모듈에 대해서는 연계성을 확인할 수 있었다. 지금 구현한 모듈이 앞으로도 쓰일 수 있기 때문에 가독성을 높이면서 최대한 임의 구현 방식을 최대한 피하기 위해 노력하였다. \\

MY\_BRAM 모듈을 구현하면서 WE signal에 따라 \texttt{mem}에 저장하는 statement를 for-generate로 구현해보려 했으나 이런 저런 오류가 나면서 나열형 방식으로 구현해 코드의 효율성이 떨어진다는 나름의 판단을 하였다. 추후 프로젝트를 진행하기 전에 always 구문 안에서 block assignment를 for-generate로 구현하는 방식을 익혀야 겠다는 필요성을 제고하였다.\\

MY\_PE 모듈 자체의 구현은 그리 어렵지 않았지만, IP catalog의 floating point MAC모듈의 내부 구조를 모르기 때문에, testbench를 작성하는데 어려움을 겪었는데, 이는 valid bit의 high 설정 후 dvalid bit가 high가 될 때까지의 정확한 clock cycle delay, valid bit와 input parameter가 동시에 할당되었을 때의 비정상적인 출력이 그리 직관적이지는 않았기 때문이라고 생각한다. MY\_PE 모듈도 이후 구현에서 중요한 부분을 차지하기 때문에, 최대한 이번 과제에만 국한되지 않게 구현하려 하였다. 
}

\bibliographystyle{plain}
\bibliography{other}

\end{document}
